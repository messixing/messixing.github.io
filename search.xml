<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[es6特性学习]]></title>
    <url>%2F2017%2F08%2F18%2Fes6-features%2F</url>
    <content type="text"><![CDATA[let,const这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。 1234567var name = 'messixing'while (true) &#123; var name = 'messi' console.log(name) //messi break&#125;console.log(name) //messi 使用var两次输出都是messi，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。 1234567let name = 'messixing'while (true) &#123; let name = 'messi' console.log(name) //messi break&#125;console.log(name) //messixing 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript模块化编程写法]]></title>
    <url>%2F2017%2F08%2F10%2Fjavascript-module-pattern%2F</url>
    <content type="text"><![CDATA[一、原始写法模块就是实现特定功能的一组方法。只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 123456function m1()&#123; //...&#125;function m2()&#123; //...&#125; 写法：只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 缺点：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 二、对象写法123456789101112var module1=new Object(&#123; _count:0, m1:function()&#123; //... &#125;, m2:function()&#123; //... &#125;&#125;);module1._count = 5;module1.m1(); 写法：把模块写成一个对象，所有的模块成员都放到这个对象里面。缺点：暴露所有模块成员，内部状态可以被外部改写。 三、立即执行函数（Immediately-Invoked Function Expression，IIFE）写法123456789101112131415161718var module1=(function()&#123; var _count=0; var m1=function()&#123; //... &#125;; var m2=function()&#123; //... &#125;; return &#123; m1:m1, m2:m2 &#125;;&#125;)();console.log(module1._count); //undefined 优点：外部代码无法读取内部变量，不暴露私有成员。 四、放大模式1234567var module1=(function(mod)&#123; mod.m3=function()&#123; //... &#125;;&#125;)(module1); 场景：如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就可以采用“放大模式”（augmentation）。释义：上面代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。 五、宽放大模式（Loose augmentation）123456var module1=(function(mod)&#123; //... return mod;&#125;)(window.module1||&#123;&#125;); 场景：在浏览器环境中，模块的各个部分通常是从网上获取的，有时无法知道哪个部分会先加载。如果采用放大模式，第一个执行的部分有可能加载一个不存在对象，这时就可采用“宽放大模式”。比较：与“放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。 六、输入全局变量12345var module1=(function($,YAHOO)&#123; //...&#125;)(jQuery,YAHOO); 场景：独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。 七、AMD规范AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： 1require([module],callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[docker如何删除image]]></title>
    <url>%2F2017%2F07%2F26%2Fdocker-delete-images%2F</url>
    <content type="text"><![CDATA[想要删除运行过的images必须首先删除它的container。 可以看出image被09f18a581eef的container使用着，所以必须首先删除该container。 再来删除image image已经删除]]></content>
  </entry>
  <entry>
    <title><![CDATA[data()和attr()的区别]]></title>
    <url>%2F2017%2F07%2F19%2Fdata-and-attr-distinction-in-jquery%2F</url>
    <content type="text"><![CDATA[html12&lt;h1 data-name="gua"&gt;你皮任你皮&lt;/h1&gt;&lt;h2 data-name="pi"&gt;你是个瓜皮&lt;/h2&gt; js1234567891011121314console.log('======h1默认值======');console.log('data方法获取',$('h1').data('name'));//guaconsole.log('attr方法获取',$('h1').attr('data-name'));//guaconsole.log('======使用data()方法修改h1======');$('h1').data('name','hhh');console.log('data方法获取',$('h1').data('name'));//hhhconsole.log('attr方法获取',$('h1').attr('data-name'));//guaconsole.log('======h2默认值======');console.log('data方法获取',$('h2').data('name'));//piconsole.log('attr方法获取',$('h2').attr('data-name'));//piconsole.log('======使用attr()方法修改h2======');$('h2').attr('data-name','www');console.log('data方法获取',$('h2').data('name'));//piconsole.log('attr方法获取',$('h2').attr('data-name'));//www $.attr()每次都从DOM元素中取属性的值，即和视图中标签内的属性值保持一致。 $.data()是从Jquery对象中取值，由于对象属性值保存在内存中，因此可能和视图里的属性值不一致的情况。 所以$.attr()和$.data()应避免混合用，也就是应该尽量避免如下两种情况的出现： 通过$.attr()来进行set属性，然后通过$.data()进行get属性值； 通过$.data()来进行set属性，然后通过$.attr()进行get属性值。 同时从性能的角度来说，建议使用$.data()来进行set和get操作，因为它仅仅修改的Jquey对象的属性值，不会引起额外的DOM操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac无法启动mysql]]></title>
    <url>%2F2017%2F07%2F18%2Fmac-can-t-start-mysql%2F</url>
    <content type="text"><![CDATA[点击start mysql server时无法启动服务，并报有 1warning the user/local/mysql/data directory is not owned by the mysql user 的提示。 解决办法：终端输入3条命令 sudo chown -RL root:mysql /usr/local/mysql sudo chown -RL mysql:mysql /usr/local/mysql/data sudo /usr/local/mysql/support-files/mysql.server start 搞定。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MAC无法安装node]]></title>
    <url>%2F2017%2F07%2F17%2FMAC-can't-install-node%2F</url>
    <content type="text"><![CDATA[卸载 node 后通过 brew 安装，出现 brew postinstall node 提示。 按照提示安装完成后，发现 node 并没有安装成功， whereis命令和 which命令都返回 node not found。 解决办法： brew update sudo chown -R $USER /usr/local brew install node brew doctor brew link node 解决完后 node -v or npm -v]]></content>
  </entry>
  <entry>
    <title><![CDATA[SkeletonScreenWithCSS]]></title>
    <url>%2F2017%2F07%2F17%2Fskeletonscreenwithcss%2F</url>
    <content type="text"><![CDATA[HTML12&lt;button&gt;Add content&lt;/button&gt;&lt;div class="demo"&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324252627282930313233343536373839.demo:empty &#123; margin: auto; width: 500px; height: 600px; background-image: radial-gradient( circle 50px at 50px 50px, lightgray 99%, transparent 0 ), linear-gradient( 100deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5) 50%, rgba(255, 255, 255, 0) 80% ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ); background-repeat: repeat-y; background-size: 100px 200px, 50px 200px, 150px 200px, 350px 200px, 300px 200px, 250px 200px; background-position: 0 0, 0 0, 120px 0, 120px 40px, 120px 80px, 120px 120px; animation: shine 1s infinite; &#125;@keyframes shine &#123; to &#123; background-position: 0 0, 100% 0, 120px 0, 120px 40px, 120px 80px, 120px 120px; &#125; &#125; JS123document.querySelector('button').addEventListener('click', function() &#123; document.querySelector('.demo').innerHTML = '&lt;h1&gt;Injected content.&lt;/h1&gt;';&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[js快速排序]]></title>
    <url>%2F2017%2F05%2F20%2Fjsquicksort%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223var quickSort = function(arr)&#123; if(arr.length&lt;=1)&#123;return arr;&#125; var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right)) ; &#125;;var arr = [5,100,6,3,-12];document.write(quickSort(arr));]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端使用JsonServer伪造数据调试后台接口]]></title>
    <url>%2F2017%2F05%2F02%2Fusejson-serverandhttpie%2F</url>
    <content type="text"><![CDATA[安装1sudo npm install -g json-server 基本使用新建一个db.json 123456789&#123;"posts": [ &#123; "id": 1, "title": "json-server", "author": "typicode" &#125;],"comments": [ &#123; "id": 1, "body": "some comment", "postId": 1 &#125;],"profile": &#123; "name": "typicode" &#125;&#125; 启动服务1json-server --watch db.json 启动成功后 访问localhost:3000/posts 利用httpie模拟数据接口增删改查安装1brew install httpie //MacOS 使用GET PUT POST DELETE]]></content>
  </entry>
  <entry>
    <title><![CDATA[OSX终端使用配置socks5 代理]]></title>
    <url>%2F2017%2F04%2F20%2FOSXterminaSocks5%2F</url>
    <content type="text"><![CDATA[如果已经启用shadowsocks 本地代理为 socks5://127.0.0.1:1080,在终端下使用 export ALL_PROXY=socks5://127.0.0.1:1080清除代理 unset ALL_PROXY为了方便呢，可以在.zshrc中加上这个 1234function setproxy() &#123; # export &#123;HTTP,HTTPS,FTP&#125;_PROXY=”http://127.0.0.1:3128” 也可以设置http代理 export ALL_PROXY=socks5://127.0.0.1:1080 &#125; 1234function unsetproxy() &#123; # unset &#123;HTTP,HTTPS,FTP&#125;_PROXY unset ALL_PROXY &#125; 需要使用代理的时候setproxy，不用了就 unsetproxy 就可以很方便的在shell环境下切换设置代理了。为了测试是否成功可以curl -i http://ip.cn 查看ip。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue2+vueRouter+webpack2学习路线（一）]]></title>
    <url>%2F2017%2F03%2F20%2Fvue2%2BvueRouter%2Bwebpack2%2F</url>
    <content type="text"><![CDATA[vue-cil构建项目首先需要安装vue-cli 1npm install -g vue-cli //全局安装vue-cli webpack初始化你的项目 1vue init webpack vueandwebpackdemo 出现提示，一路回车 进入项目文件夹 1cd vueandwebpackdemo 安装依赖 1npm install 这个安装时间贼长，耐心等待 最后，把项目跑起来 1npm run dev 完结撒花！]]></content>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组操作总结]]></title>
    <url>%2F2017%2F03%2F08%2FJs-Array-operation-summary%2F</url>
    <content type="text"><![CDATA[1.数组的创建123var arrayObj = new Array(); //创建一个数组var arrayObj = new Array([size]); //创建一个数组并指定长度，注意不是上限，是长度var arrayObj = new Array([element0[, element1[, ...[, elementN]]]]); //创建一个数组并赋值 2.数组的元素访问12var testGetArrValue=arrayObj[1]; //获取数组的元素值arrayObj[1]= "这是新值"; //给数组元素赋予新的值 3.数组元素的添加123arrayObj. push([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组结尾，并返回数组新长度arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度arrayObj.splice(insertPos,0,[item1[, item2[, . . . [,itemN]]]]);//将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回"" 4.数组元素的删除123arrayObj.pop(); //移除最后一个元素并返回该元素值arrayObj.shift(); //移除最前一个元素并返回该元素值，数组中元素自动前移arrayObj.splice(deletePos,deleteCount); //删除从指定位置deletePos开始的指定数量deleteCount的元素，数组形式返回所移除的元素 5.数组的截取和合并12arrayObj.slice(start, [end]); //以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素arrayObj.concat([item1[, item2[, . . . [,itemN]]]]); //将多个数组（也可以是字符串，或者是数组和字符串的混合）连接为一个数组，返回连接好的新的数组 6.数组的拷贝12arrayObj.slice(0); //返回数组的拷贝数组，注意是一个新的数组，不是指向arrayObj.concat(); //返回数组的拷贝数组，注意是一个新的数组，不是指向 7.数组元素的排序12arrayObj.reverse(); //反转元素（最前的排到最后、最后的排到最前），返回数组地址arrayObj.sort(); //对数组元素排序，返回数组地址 8.数组元素的字符串化join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 123arrayObj.join(separator); //返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 valueOf: 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 1234var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 toLocaleString 、toString：可以看作是join的特殊用法，不常用; toLocaleString(): 方法可根据本地时间把 Date 对象转换为字符串，并返回结果。 toString:把数组转换为字符串，并返回结果。 lastIndexOf：返回在数组中搜索到的与给定参数相等的元素的最后（最大）索引。 toSource(): 返回一个字符串,代表该数组的源代码.该特性是非标准的，请尽量不要在生产环境中使用它！]]></content>
  </entry>
  <entry>
    <title><![CDATA[django学习路线（二）]]></title>
    <url>%2F2017%2F02%2F12%2FlearntoDjango2%2F</url>
    <content type="text"><![CDATA[Django Model 每一个Django Model都继承自django.db.models.Model 在Model当中每一个属性attribute都代表一个database field 通过Django Model API可以执行数据库的增删改查, 而不需要写一些数据库的查询语句设置数据库 Django项目建成后, 默认设置了使用SQLite数据库, 在my_blog/my_blog/setting.py中可以查看和修改数据库设置:123456DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &#125;&#125; 还可以设置其他数据库, 如MySQL, PostgreSQL, 现在为了简单, 使用默认数据库设置 创建models在my_blog/article/models.py下编写如下程序:1234567891011from django.db import models# Create your models here.class Article(models.Model) : title = models.CharField(max_length = 100) #博客题目 category = models.CharField(max_length = 50, blank = True) #博客标签 date_time = models.DateTimeField(auto_now_add = True) #博客日期 content = models.TextField(blank = True, null = True) #博客文章正文 def __unicode__(self) : return self.title class Meta: #按时间下降排序 ordering = [&apos;-date_time&apos;] 其中__unicode__(self)函数Article对象要怎么表示自己, 一般系统默认使用&lt;Article: Article object&gt;来表示对象, 通过这个函数可以告诉系统使用title字段来表示这个对象 CharField 用于存储字符串, max_length设置最大长度 TextField 用于存储大量文本 DateTimeField 用于存储时间, auto_now_add设置True表示自动设置对象增加时间同步数据库 1$ python3 manage.py migrate #命令行运行该命令 因为我们已经执行过该命令会出现如下提示123456Operations to perform: Apply all migrations: admin, contenttypes, sessions, authRunning migrations: No migrations to apply. Your models have changes that are not yet reflected in a migration, and so won&apos;t be applied. Run &apos;manage.py makemigrations&apos; to make new migrations, and then re-run &apos;manage.py migrate&apos; to apply them. 那么现在需要执行下面的命令123456$ python3 manage.py makemigrations#得到如下提示Migrations for &apos;article&apos;: 0001_initial.py: - Create model Article 现在重新运行以下命令123456$ python3 manage.py migrate#出现如下提示表示操作成功Operations to perform: Apply all migrations: auth, sessions, admin, article, contenttypesRunning migrations: Applying article.0001_initial... OK migrate命令按照app顺序建立或者更新数据库, 将models.py与数据库同步 Django Shell现在我们进入Django中的交互式shell来进行数据库的增删改查等操作123456$ python3 manage.py shellPython 3.4.2 (v3.4.2:ab2c023a9432, Oct 5 2014, 20:42:22)[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.(InteractiveConsole)&gt;&gt;&gt; 这里进入Django的shell和python内置的shell是非常类似的12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; from article.models import Article&gt;&gt;&gt; #create数据库增加操作&gt;&gt;&gt; Article.objects.create(title = &apos;Hello World&apos;, category = &apos;Python&apos;, content = &apos;我们来做一个简单的数据库增加操作&apos;)&lt;Article: Article object&gt;&gt;&gt;&gt; Article.objects.create(title = &apos;Django Blog学习&apos;, category = &apos;Python&apos;, content = &apos;Django简单博客教程&apos;)&lt;Article: Article object&gt;&gt;&gt;&gt; #all和get的数据库查看操作&gt;&gt;&gt; Article.objects.all() #查看全部对象, 返回一个列表, 无对象返回空list[&lt;Article: Article object&gt;, &lt;Article: Article object&gt;]&gt;&gt;&gt; Article.objects.get(id = 1) #返回符合条件的对象&lt;Article: Article object&gt;&gt;&gt;&gt; #update数据库修改操作&gt;&gt;&gt; first = Article.objects.get(id = 1) #获取id = 1的对象&gt;&gt;&gt; first.title&apos;Hello World&apos;&gt;&gt;&gt; first.date_timedatetime.datetime(2014, 12, 26, 13, 56, 48, 727425, tzinfo=&lt;UTC&gt;)&gt;&gt;&gt; first.content&apos;我们来做一个简单的数据库增加操作&apos;&gt;&gt;&gt; first.category&apos;Python&apos;&gt;&gt;&gt; first.content = &apos;Hello World, How are you&apos;&gt;&gt;&gt; first.content #再次查看是否修改成功, 修改操作就是点语法&apos;Hello World, How are you&apos;&gt;&gt;&gt; #delete数据库删除操作&gt;&gt;&gt; first.delete()&gt;&gt;&gt; Article.objects.all() #此时可以看到只有一个对象了, 另一个对象已经被成功删除[&lt;Article: Article object&gt;]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django学习路线]]></title>
    <url>%2F2017%2F02%2F11%2FlearntoDjango1%2F</url>
    <content type="text"><![CDATA[Django安装安装最新版的Django版本1234#安装最新版本的Django$ pip3 install django #或者指定安装版本pip3 install -v django==1.7.1 项目创建创建一个名为my_blog的Django项目 创建项目的指令如下:1$ django-admin.py startproject my_blog 整个项目的文件结构:123456789$ tree my_blog #打印树形文件结构my_blog├── manage.py└── my_blog ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py1 directory, 5 files 建立Django app建立一个articleapp 1$ python3 manage.py startapp article 重新看一下整个项目的结构:1234567891011121314151617181920── article│ ├── __init__.py│ ├── admin.py│ ├── migrations│ │ └── __init__.py│ ├── models.py│ ├── tests.py│ └── views.py├── db.sqlite3├── manage.py├── my_blog ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-34.pyc │ ├── settings.cpython-34.pyc │ ├── urls.cpython-34.pyc │ └── wsgi.cpython-34.pyc ├── settings.py ├── urls.py └── wsgi.py 并在my_blog/my_blog/setting.py下添加新建app1234INSTALLED_APPS = ( ... &apos;article&apos;, #这里填写的是app的名称) 运行程序1$ python3 manage.py runserver #启动Django中的开发服务器 12345678910111213如果运行上面命令出现以下提示You have unapplied migrations; your app may not work properly until they are applied.Run &apos;python manage.py migrate&apos; to apply them.请先使用下面命令python3 manage.py migrate输出如下信息Operations to perform: Apply all migrations: contenttypes, sessions, admin, authRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying sessions.0001_initial... OK 运行成功后,会显示如下信息12345678重新运行启动Django中的开发服务器$ python3 manage.py runserver运行成功显示如下信息System check identified no issues (0 silenced).December 21, 2014 - 08:56:00Django version 1.7.1, using settings &apos;my_blog.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 现在可以启动浏览器, 输入http://127.0.0.1:8000/, 当出现说明你成功走出了第一步!]]></content>
  </entry>
  <entry>
    <title><![CDATA[志明与春娇]]></title>
    <url>%2F2016%2F08%2F29%2F%E5%BF%97%E6%98%8E%E4%B8%8E%E6%98%A5%E5%A8%87%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Js获取当前日期时间]]></title>
    <url>%2F2016%2F08%2F11%2FJs-Date%2F</url>
    <content type="text"><![CDATA[1234567891011121314var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript技巧]]></title>
    <url>%2F2016%2F08%2F05%2Fjavascript-technique%2F</url>
    <content type="text"><![CDATA[使用对象构造器12345function Person(firstName, lastName)&#123; this.firstName = firstName; this.lastName = lastName;&#125;var Saad = new Person("Saad", "Mousliki"); 小心使用typeof、instanceof和contructor typeof：JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，typeof null也会返回object，大多数的对象类型（数组Array、时间Date等）也会返回object contructor：内部原型属性，可以通过代码重写 instanceof：JavaScript操作符，会在原型链中的构造器中搜索，找到则返回true，否则返回false 1234var arr = ["a", "b", "c"];typeof arr; // 返回 "object" arr instanceof Array // truearr.constructor(); //[] 使用自调用函数函数在创建之后直接自动执行，通常称之为自调用匿名函数（Self-Invoked Anonymous Function）或直接调用函数表达式（Immediately Invoked Function Expression ）。格式如下：1234567(function()&#123; // 置于此处的代码将自动执行&#125;)(); (function(a,b)&#123; var result = a+b; return result;&#125;)(10,20) 从数组中随机获取成员12var items = [12, 548 , 'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' , 2145 , 119];var randomItem = items[Math.floor(Math.random() * items.length)]; 获取指定范围内的随机数这个功能在生成测试用的假数据时特别有数，比如介与指定范围内的工资数。1var x = Math.floor(Math.random() * (max - min + 1)) + min; 生成从0到指定值的数字数组12var numbersArray = [] , max = 100;for( var i=1; numbersArray.push(i++) &lt; max;); // numbers = [1,2,3 ... 100] 生成随机的字母数字字符串12345function generateRandomAlphaNum(len) &#123; var rdmString = ""; for( ; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len);&#125; 打乱数字数组的顺序123var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];numbers = numbers.sort(function()&#123; return Math.random() - 0.5&#125;);/* numbers 数组将类似于 [120, 5, 228, -215, 400, 458, -85411, 122205] */ 数组之间追加123var array1 = [12 , "foo" , &#123;name "Joe"&#125; , -2458];var array2 = ["Doe" , 555 , 100];Array.prototype.push.apply(array1, array2); 对象转换为数组1var argArray = Array.prototype.slice.call(arguments); 验证是否是数字123function isNumber(n)&#123; return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#125; 获取数组中的最大值和最小值123var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; var maxInNumbers = Math.max.apply(Math, numbers); var minInNumbers = Math.min.apply(Math, numbers); 清空数组12var myArray = [12 , 222 , 1000 ]; myArray.length = 0; 不要直接从数组中delete或remove元素如果对数组元素直接使用delete，其实并没有删除，只是将元素置为了undefined。数组元素删除应使用splice。切忌：12345var items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ]; items.length; // return 11 delete items[3]; // return true items.length; // return 11 /* items 结果为 [12, 548, "a", undefined × 1, 5478, "foo", 8852, undefined × 1, "Doe", 2154, 119] */ 而应：1234var items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ]; items.length; // return 11 items.splice(3,1) ; items.length; // return 10 删除对象的属性时可以使用delete。 使用length属性截断数组12var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ]; myArray.length = 4; 与此同时，如果把length属性变大，数组的长度值变会增加，会使用undefined来作为新的元素填充。length是一个可写的属性。12myArray.length = 10; // the new array length is 10 myArray[myArray.length - 1] ; // undefined 使用map()函数方法对数据循环123var squares = [1,2,3,4].map(function (val) &#123; return val * val; &#125;); 保留指定小数位数12var num =2.443242342;num = num.toFixed(4); 注意，toFixec()返回的是字符串，不是数字。 通过for-in循环检查对象的属性下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。12345for (var name in object) &#123; if (object.hasOwnProperty(name)) &#123; // do something with name &#125; &#125; 临时存储用于计算和查询的变量在jQuery选择器中，可以临时存储整个DOM元素。1234var navright = document.querySelector('#right'); var navleft = document.querySelector('#left'); var navup = document.querySelector('#up'); var navdown = document.querySelector('#down');]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS实现垂直居中的5种方法]]></title>
    <url>%2F2016%2F07%2F29%2FCSS-centre%20horizontal%2F</url>
    <content type="text"><![CDATA[方法一这个方法把一些 div 的显示方式设置为表格，因此我们可以使用表格的 vertical-align property 属性。12345&lt;div id="wrapper"&gt; &lt;div id="cell"&gt; &lt;div class="content"&gt;Content goes here&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678#wrapper &#123; display: table;&#125;#cell &#123; display: table-cell; vertical-align: middle;&#125; 优点： content可以动态改变高度(不需在 CSS 中定义)。当wrapper里没有足够空间时， content 不会被截断 缺点： Internet Explorer(甚至 IE8 beta)中无效，许多嵌套标签 方法二这个方法使用绝对定位的div，把它的top设置为50％，top margin 设置为负的content高度。这意味着对象必须在 CSS 中指定固定的高度。因为有固定高度，或许你想给content指定overflow:auto，这样如果content 太多的话，就会出现滚动条，以免content溢出。1&lt;div class="content"&gt; Content goes here&lt;/div&gt; 123456#content &#123;position: absolute;top: 50%;height: 240px;margin-top: -120px; /* negative half of the height */&#125; 优点： 适用于所有浏览器 不需要嵌套标签 缺点： 没有足够空间时content会消失(类似div在body内，当用户缩小浏览器窗口，滚动条不出现的情况) 方法三这种方法，在content元素外插入一个div。设置此div``height:50%; margin-bottom:-contentheight;。content清除浮动，并显示在中间。123&lt;div id="floater"&gt; &lt;div id="content"&gt;Content here&lt;/div&gt;&lt;/div&gt; 12345678910 #floater &#123; float: left; height: 50%; margin-bottom: -120px; &#125; #content &#123; clear: both; height: 240px; position: relative;&#125; 优点： 适用于所有浏览器 没有足够空间时（例如：窗口缩小）content不会被截断，滚动条出现 缺点： 需要额外的空元素 方法四这个方法使用了一个position:absolute，有固定宽度和高度的div。这个div被设置为top:0; bottom:0;。但是因为它有固定高度，其实并不能和上下都间距为0，因此margin:auto; 会使它居中。使用margin:auto;使块级元素垂直居中是很简单的。1&lt;div id="content"&gt; Content here&lt;/div&gt; 12345678910#content &#123;position: absolute;top: 0;bottom: 0;left: 0;right: 0;margin: auto;height: 240px;width: 70%;&#125; 缺点 IE(IE8 beta)中无效 无足够空间时，content被截断，但是不会有滚动条出现 方法五这个方法只能将单行文本置中。只需要简单地把line-height设置为那个对象的height 值就可以使文本居中了。1&lt;div id="content"&gt; Content here&lt;/div&gt; 1234#content &#123;height: 100px;line-height: 100px;&#125; 优点： 适用于所有浏览器 无足够空间时不会被截断 缺点： 只对文本有效(块级元素无效) 多行时，断词比较糟糕]]></content>
  </entry>
  <entry>
    <title><![CDATA[几种前端储存]]></title>
    <url>%2F2016%2F07%2F29%2FsomefrontStorage%2F</url>
    <content type="text"><![CDATA[1 老朋友cookie1.1 访问限制性cookie可以设置访问域。即，如果你设置cookie的时候，设定了cookie的访问域名为一个顶级域名，则可以达到几个子域名共享cookie的效果。访问的限制在种下cookie的时候指定。所以，我们可以设定cookie的访问域名限制(不能跨域)。有些重要信息，如用户的唯一标识，建议给这些cookie字段加上HttpOnly标识。加上了这个标识的话，我们的客户端js是无法读到与写入加了标识的cookie字段的，这样非常安全。 1.2 存储时长如果设定了cookie的超时时间的话，那么cookie将在到期的时候失效。如果没有设定，那么cookie就是session级别的啦。cookie的session是，在未关闭浏览器的情况下，所有的tab级别的页面或新开，或刷新，均属于一个session。 1.3 做什么比较好？一般非到不得已，不要在cookie里面存东西。如果要存储的话。建议存储一些同步访问页面的时候必须要被带到服务端的信息。比如，网站的用户登录信息。这个是在访问时必须要在服务端获取的信息，所以种在cookie里面很必要。有的同学会说了，那一些用户信息呢？比如用户在我网站都买了什么东西，之类的。这里建议存储在服务端(存在数据库里面，或者什么里面)。然后使用用户的cookie唯一ID去数据库中查询。 2 短暂的sessionStorage2.1 什么是sessionStoragesessionStorage属于webstorage的一种，sessionStorage与我们稍后要说的localStorage类似，可以存储k-v形式的数据，使用方法非常简单set便可以存储。sessionStorage.setItem(&#39;test&#39;, &#39;messixing&#39;);使用sessionStorage.getItem便可以直接获取。sessionStorage.getItem(&#39;test&#39;);顾名思义，sessionStorage，是session级别的存储。其存储于客户端。服务端是无法直接拿到的。 2.2 访问限制性不同于cookie，sessionStorage的访问限制更高一些，只有当前设定sessionStorage的域下才能访问，而且不同的两个tab之间不能互通。sessionStorage里面的session，并不同于cookie，是以tab为级别的session。 2.3 做什么比较好？既然是存储于客户端而且存储级别仅仅是一个session的话，还是建议存储一些当前页面刷新需要存储，且不需要在tab关闭时候留下的信息。刚刚说了，只有页面刷新才不会清除掉sessionStorage。剩下的均会清理掉sessionStorage，当然，也许可以用sessionStorage来检测用户是否是刷新进入的页面。对于音乐播放器恢复播放进度条等功能等还是挺实用的。 3 简易强大的localStorage3.1 什么是localStorage？localStorage与sessionStorage较为相似，接口也简单，通过localStorage.setItem/localStorage.getItem即可轻松使用。localStorage.setItem(&#39;test&#39;, &#39;doctorhou&#39;); localStorage.getItem(&#39;test&#39;);localStorage可以存储k-v形式的数据。存储的值需要是字符串类型，没法直接存储对象，但是可以将对象序列化为字符串再存入。如果强行存入object的话，就会被调用object.toString从而悲剧。正确的存法：123456var messixing = &#123; name: 'messixing', describe: '高大、威猛、帅气'&#125;;localStorage.setItem('test', JSON.stringify(messixing));JSON.parse(localStorage.getItem('test')); localStorage的存储周期比sessionStorage长，如果用户不清理的话，是可以永久存储的。 3.2 访问的限制性localStorage与sessionStorage虽然相似，但是访问限制却不尽相同，localStorage的访问域默认设定为设置localStorage的当前域，其他域名不可以取。这点与sessionStorage相同，但是与sessionStorage不同的是，localStorage设定后，新开tab是可以访问到的。 3.3 存储时间localStorage理论上讲是永久性质的存储。但是，免不了用户会使用浏览器清除数据，或者浏览器有时候为了节省，去清除数据。 3.4 大小限制localStorage的大小一般限定为4M左右。 3.5 做什么比较好？由于localStorage的稳定性质，及其长效的存储。建议如果有一些数据，服务器难以承载其压力，但又要与用户的信息绑定的话，可以使用localStorage存储一些状态，这样即能缓解服务端压力，也可以存储用户的数据。 4 websql与indexeddb]]></content>
  </entry>
  <entry>
    <title><![CDATA[jquery.cookie.js 使用方法]]></title>
    <url>%2F2015%2F03%2F30%2Fjquery-cookie%2F</url>
    <content type="text"><![CDATA[1.添加一个”会话cookie”1$.cookie('the_cookie', 'the_value'); 2.创建一个cookie并设置有效时间为 7天1$.cookie('the_cookie', 'the_value', &#123; expires: 7 &#125;); 3.创建一个cookie并设置 cookie的有效路径1$.cookie('the_cookie', 'the_value', &#123; expires: 7, path: '/' &#125;); 4.读取cookie1$.cookie('the_cookie'); 5.删除cookie1$.cookie('the_cookie', null); //通过传递null作为cookie的值即可 6.可选参数123456$.cookie('the_cookie','the_value',&#123; expires:7, path:'/', domain:'jquery.com', secure:true&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用js取得文件扩展名]]></title>
    <url>%2F2015%2F03%2F27%2FUse-js-to-get-the-file-extension%2F</url>
    <content type="text"><![CDATA[12345678var file1 = "50.xsl";var file2 = "30.doc";getFileExtension(file1); //returs xslgetFileExtension(file2); //returs docfunction getFileExtension(filename) &#123; /*TODO*/&#125; 解决方法1：正则表达式123function getFileExtension1(filename) &#123; return (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename)[0] : undefined;&#125; 解决方法 2: String的split方法123function getFileExtension2(filename) &#123; return filename.split('.').pop();&#125; 解决方法 3: String的slice、lastIndexOf方法123456789function getFileExtension3(filename) &#123; return filename.slice((filename.lastIndexOf(".") - 1 &gt;&gt;&gt; 0) + 2);&#125;console.log(getFileExtension3('')); // ''console.log(getFileExtension3('filename')); // ''console.log(getFileExtension3('filename.txt')); // 'txt'console.log(getFileExtension3('.hiddenfile')); // ''console.log(getFileExtension3('filename.with.many.dots.ext')); // 'ext']]></content>
  </entry>
  <entry>
    <title><![CDATA[十条jQuery代码片段]]></title>
    <url>%2F2015%2F03%2F25%2FjQuerycodesnippet%2F</url>
    <content type="text"><![CDATA[检测IE浏览器在进行CSS设计时，IE浏览器对开发者及设计师而言无疑是个麻烦。尽管IE6的黑暗时代已经过去，IE浏览器家族的人气亦在不断下滑，但我们仍然有必要对其进行检测。当然，以下片段亦可用于检测其它浏览器。12345$(document).ready(function() &#123; if (navigator.userAgent.match(/msie/i) )&#123; alert('I am an old fashioned Internet Explorer'); &#125; &#125;); 平滑滚动至页面顶部以下是jQuery最为常见的一种实现效果：点击一条链接以平滑滚动至页面顶部。虽然没什么新鲜感可言，但每位开发者几乎都用得上。1234$("a[href='#top']").click(function() &#123; $("html, body").animate(&#123; scrollTop: 0 &#125;, "slow"); return false; &#125;); 保持始终处于顶部以下代码片段允许某一元素始终处于页面顶部。可以想见，其非常适合处理导航菜单、工具栏或者其它重要信息。1234567891011121314151617$(function()&#123; var $win = $(window) var $nav = $('.mytoolbar'); var navTop = $('.mytoolbar').length &amp;&amp; $('.mytoolbar').offset().top; var isFixed=0; processScroll(); $win.on('scroll', processScroll); function processScroll() &#123; var i, scrollTop = $win.scrollTop() if (scrollTop &gt;= navTop &amp;&amp; !isFixed) &#123; isFixed = 1 $nav.addClass('subnav-fixed') &#125; else if (scrollTop &lt;= navTop &amp;&amp; isFixed) &#123; isFixed = 0 $nav.removeClass('subnav-fixed') &#125; &#125; 替换html标签1234jQuery能够非常轻松地实现html标签替换，而这也将为我们带来更多新的可能。$('li').replaceWith(function()&#123; return $("&lt;div /&gt;").append($(this).contents()); &#125;); 检测屏幕宽度12345var responsive_viewport = $(window).width(); /* if is below 481px */ if (responsive_viewport &lt; 481) &#123; alert('Viewport is smaller than 481px.'); &#125; /* end smallest screen */ 自动修复损坏图片如果大家的站点非常庞大而且已经上线数年，那么其中或多或少会出现图片损坏的情况。这项功能可以检测损坏图片并根据我们的选择加以替换。123$('img').error(function()&#123; $(this).attr('src', 'img/broken.png'); &#125;); 检测复制、粘贴与剪切操作利用jQuery，大家可以非常轻松地检测到选定元素的复制、粘贴与剪切操作。123456789$("#textA").bind('copy', function() &#123; $('span').text('copy behaviour detected!') &#125;); $("#textA").bind('paste', function() &#123; $('span').text('paste behaviour detected!') &#125;); $("#textA").bind('cut', function() &#123; $('span').text('cut behaviour detected!') &#125;); 自动为外部链接添target=“blank”属性在链接至外部站点时，大家可能希望使用target=”blank”属性以确保在新的选项卡中打开页面。问题在于，target=”blank”属性并未经过W3C认证。jQuery能够帮上大忙：以下片段能够检测当前链接是否指向外部，如果是则自动为其添加target=”blank”属性。1234var root = location.protocol + '//' + location.host; $('a').not(':contains(root)').click(function()&#123; this.target = "_blank"; &#125;); 悬停时淡入/淡出12345678$(document).ready(function()&#123; $(".thumbs img").fadeTo("slow", 0.6); // This sets the opacity of the thumbs to fade down to 60% when the page loads $(".thumbs img").hover(function()&#123; $(this).fadeTo("slow", 1.0); // This should set the opacity to 100% on hover &#125;,function()&#123; $(this).fadeTo("slow", 0.6); // This should set the opacity back to 60% on mouseout &#125;); &#125;); 禁用文本/密码输入中的空格无论是电子邮件、用户名还是密码，很多常见字段都不需要使用空格。以下代码能够轻松禁用选定输入内容中的全部空格。12345$('input.nospace').keydown(function(e) &#123; if (e.keyCode == 32) &#123; return false; &#125; &#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于Deployer not found: git的问题]]></title>
    <url>%2F2015%2F03%2F18%2Fabout-Deployer-not-found-git%2F</url>
    <content type="text"><![CDATA[修改好主题文件夹里的_config.yml文件后进行hexo g再hexo d会报出错误 ERROR Deployer not found: git这时需要先npm install hexo-deployer-git --save再hexo ghexo d就会提示 Deploy done: git ps:前提 _config.yml 中type先设置为git]]></content>
  </entry>
</search>
